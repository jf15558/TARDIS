% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detour.R
\name{detour}
\alias{detour}
\title{detours}
\usage{
detour(
  tardis,
  weights = NULL,
  paths,
  pindex = NULL,
  detour = 0.01,
  verbose = TRUE
)
}
\arguments{
\item{tardis}{An object of class 'tardis', produced by create_tardis}

\item{weights}{If not NULL, a vector of weights to be used instead of the
geographic distances in tardis. All entries must be >= 0
and finite (NaN or Inf), or NA. Typically the output of weight_tgraph}

\item{paths}{An object returned by the lcp function.}

\item{pindex}{The indices of the least cost paths in 'paths' to calculate
detours for. If NULL, then all paths will be analysed.}

\item{detour}{The proportional extra cost to detect accessible cells within,
a numeric > 0. The default is 1\% (i.e. 0.01). Optionally, a vector with as
many elements as pindex, to enable different detour amounts for each path.}

\item{verbose}{A logical indicating whether function progress should be
reported to the user.}
}
\value{
If no detours could be calculated for any of the paths, the function
will return NULL. Otherwise a simple features geometry collection, with a
multipolygon for each path where a detour could be calculated. As least cost
paths can extend across multiple time bins, the polygons in a multipolygon
represent bin-specific segments of the overall detour.
}
\description{
Calculate detours around least cost paths from tardis. The function identifies
all cells accessible from the least cost path within a certain proportional
additional cost relative to the cost of that least cost path. Detour
calculation within the tardis spatiotemporal graphs is performed by the
get_detour function of the cppRouting package. As defined there, accessible
cells (n) from the least cost path are those that meet the condition:
SP(o,n) + SP(n,d) < SP(o,d) + t, where SP is the cost of access, o the origin
node, d the destination node and t the extra cost. Any identified cells are
then converted to coordinates and the concave hull for that set of coordinates
calculated and returned.
}
\examples{
#library(terra)
#library(TARDIS)

#data("galapagos")
#gal <- unwrap(galapagos)
#gal <- crop(gal, extent(-92, -88, -2, 1))
#gal_m <- classify(gal, rcl = matrix(c(-Inf, 0, NA, 0, Inf, 1),
#                                    ncol = 3, byrow = T), right = F)
#gt <- create_tardis(gal, times = c(seq(2.25, 0, -0.5), 0), mask = gal_m)

#vars = list(elev = classify(gal, cbind(-Inf, 0, 0)))
#gtw <- weight_tardis(test2, vars = vars,
#                     mfun = function(origin, dest, lnum, ...) {
#                               (origin$hdist^2 + abs(origin$vdist)^2) * 10})

#org <- rbind(c(-89, -1.05, 2), c(-89.5, -0.7, 2))
#dst <- rbind(c(-91.2, -1, 0), c(-91.6, -0.4, 0))
#pts <- stp(test2, rbind(org, dst))

#foo <- lcp(tardis = gt, weights = gtw, pts[1:2,], pts[3:4,])
#foo2 <- detour(tardis = gt, weights = gtw, foo, detour = 0.01)
}
