% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/isochrone.R
\name{isochrone}
\alias{isochrone}
\title{isochrone}
\usage{
isochrone(
  tardis,
  weights = NULL,
  origin,
  cost = 1e+05,
  restrict = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{tardis}{An object of class 'tardis', produced by create_tardis}

\item{weights}{If not NULL, a vector of weights to be used instead of the
geographic distances in tardis. All entries must be >= 0
and finite (NaN or Inf), or NA. Typically the output of weight_tgraph}

\item{origin}{A simple features collection produced by stp, denoting
the starting points of the random walks.}

\item{cost}{The maximum cumulative cost of below which cells will be
included within the isochrone in a point's time-specific origin landscape
layer, either a single number or a vector with as many elements as pindex,
to enable different costs for each point. Cost will increase proportionally
in successive layers away from the origin as described above.}

\item{restrict}{A logical indicating whether the isochrone should be
constrained to the same time layer as its origin. TRUE by default.}

\item{verbose}{A logical indicating whether function progress should be
reported to the user.}
}
\value{
If restrict = TRUE (default), then a SpatRaster with each layer
recording the frequencies of cell visits. If restrict = FALSE, a list of
SpatRasters, with each named layer recording the frequencies of cells visited
in each landscape layer through time
}
\description{
Calculate a cost isochrone around a point, that is all cells which fall
within a certain cost of access of that point, based on the cumulative
cost of traversing to those surrounding cells. Isochrones are calculated
within the time-specific landscape layer for a given point by default,
rather than also extending along temporal links. Full space-time
isochrones can be obtained, but it is not necessarily obvious how the cost
should ideally change with temporal distance from the origin.
}
\examples{
#library(terra)
#library(TARDIS)

#gal <- galapagos()
#gal <- crop(gal, extent(-92, -88, -2, 1))
#gal_m <- classify(gal, rcl = matrix(c(-Inf, 0, NA, 0, Inf, 1),
#                                    ncol = 3, byrow = T), right = F)
#gt <- create_tardis(gal, times = c(seq(2.25, 0, -0.5), 0), mask = gal_m)

#vars = list(elev = classify(gal, cbind(-Inf, 0, 0)))
#gtw <- weight_tardis(test2, vars = vars,
#                     mfun = function(origin, dest, lnum, ...) {
#                               (origin$hdist^2 + abs(origin$vdist)^2) * 10})

#org <- rbind(c(-89, -1.05, 2), c(-89.5, -0.7, 2))
#dst <- rbind(c(-91.2, -1, 0), c(-91.6, -0.4, 0))
#pts <- stp(test2, rbind(org, dst))

#foo <- lcp(tardis = gt, weights = gtw, pts[1:2,], pts[3:4,])
#foo2 <- isochrone(tardis = gt, weights = gtw, foo)
}
